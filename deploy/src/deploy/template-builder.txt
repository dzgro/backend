AWS SAM Template Requirements

General
- Create a separate template file for each region.
- Use mapping.py to determine which resources (functions, queues, buckets) belong in each region's template.

Lambda Functions
- Only include functions in the template if the region is present in the function's region array in FUNCTIONS_MAP.
- Use the exact key from FUNCTIONS_MAP as the resource name, appended with Function (e.g., amazon_daily_reportFunction).
- Set the following properties for each function:
  - Handler: handler.handler
  - Runtime: python3.12
  - Architectures: ["x86_64"]
  - CodeUri: Use the path value from FUNCTIONS_MAP
  - Description: Use the description value from FUNCTIONS_MAP
  - Timeout: 900
  - Layers: List containing the ARN of the published layer for that region
  - Role: ARN of the IAM role to be attached to the Lambda function

SQS Queues

Resource Naming for SQS Queues:
- For every main queue, use the resource name: <queue_key>-Q
- For every dead letter queue, use the resource name: <queue_key>-DLQ
- Set the `QueueName` property to the key in the QUEUES_MAP object (without the -Q or -DLQ suffix).
- Set the `VisibilityTimeout` property to 60 seconds for every queue.
- For every queue, create a dead letter queue (DLQ) with the same name appended by '-DLQ'.
- Set `maxReceiveCount` to 1 in the `RedrivePolicy` for each queue, so messages are moved to the DLQ after one failed processing attempt.
- Only create the queue in the template for regions listed in its region array.
- The function property in the queue object refers to a Lambda function also created in the template.
- If the function property is present, configure the SQS queue to trigger the specified Lambda function by setting up an event source mapping from the queue to the Lambda.
- Ensure the event source mapping is present in the template for such queues, using the main queue resource name (<queue_key>-Q).
- For Every Queue in Default Region, create another queue with name appended by '-Test' and dont invoke any lambda
- For Every queue, put Tag 'Environment' as 'Test' or 'Prod'

S3 Buckets

S3 Buckets
- Each region will have a set of S3 buckets (details for buckets to be provided or derived from mapping.py).
- The following buckets should be created in the template for the default region (as defined in mapping.py):
  - dzgro-reports
  - dzgro
  - dzgro-invoices
  - dzgro-cloudfront

Resource Naming for S3 Buckets:
- For each bucket, use the resource name as the bucket name with hyphens removed and title-cased (e.g., dzgro-reports -> DzgroReports).
- Set the Properties->BucketName to the exact value in the array (e.g., dzgro-reports, dzgro, dzgro-invoices, dzgro-cloudfront).

Layer
- The Lambda layer is region-specific and must be published in each region.
- The ARN for the layer must be used in the Layers property for each function in that region.

API Gateway
- The API Gateway should be created only for the default region (as defined in mapping.py).
- For each queue in QUEUES_MAP, if the `routes` property (an array) is present, add an API Gateway route for each entry in the array using the specified `path` and `method`.
- Each route in the array should be integrated with the relevant Lambda or SQS resource as appropriate.
- Ensure all API Gateway routes and integrations follow the logic and requirements defined below for multiple routes per queue.

API Gateway Route Mapping
- For each route in the `routes` array of a queue object:
  - If `destination` is set to Lambda, map the API Gateway route to trigger the corresponding Lambda function via the API.
  - If `destination` is set to SQS, map the API Gateway route to send messages to the corresponding SQS queue via the API.
- Use this logic to create the correct API Gateway integration objects in the template.

API Gateway Route Destination Types

For every route in the `routes` array of a queue object, you need to specify what type of destination it connects to. There are two types:

1. **Lambda Destination**
   - The route will call a Lambda function.
   - You must set up an API Gateway integration of type `aws`.
   - Use `httpMethod: POST`.
   - The `uri` should point to the Lambda function's ARN.
   - The `credentials` field should reference the API Gateway integration role ARN you provide as an argument.
   - The request template for JSON should look like this:

     Example:
     ```yaml
     x-amazon-apigateway-integration:
       type: aws
       httpMethod: POST
       uri: arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaFunctionArn}/invocations
       credentials: <ApiGatewayIntegrationRoleArn>
       requestTemplates:
         application/json: |
           {
             "body": $input.json('$')
           }
     ```

2. **SQS Destination**
   - The route will send a message to an SQS queue.
   - You must set up an API Gateway integration of type `aws`.
   - Use `httpMethod: POST`.
   - The `uri` should point to the SQS queue's ARN.
   - The `credentials` field should reference the API Gateway integration role ARN you provide as an argument.
   - The request template for form data should look like this:

     Example:
     ```yaml
     x-amazon-apigateway-integration:
       type: aws
       httpMethod: POST
       uri: arn:aws:apigateway:${AWS::Region}:sqs:path/${AWS::AccountId}/${QueueName}
       credentials: <ApiGatewayIntegrationRoleArn>
       requestParameters:
         integration.request.header.Content-Type: "'application/x-www-form-urlencoded'"
       requestTemplates:
         application/x-www-form-urlencoded: |
           Action=SendMessage&MessageBody=$input.body
           # If the queue object's headers array is non-empty (headers is a list of strings):
           #   - Add an ampersand (&) after MessageBody.
           #   - For each header string, add:
           #     MessageAttribute.{idx}.Name={header}&MessageAttribute.{idx}.Value.StringValue="$input.params().header.get('{header}')"&MessageAttribute.{idx}.Value.DataType=String
           #     (Each MessageAttribute field should be followed by an ampersand except the last one.)
           # If there are no headers, do not add the ampersand (&) or any MessageAttribute fields.
           # Example (with headers = ["EventType", "SourceSystem"]):
           # Action=SendMessage&MessageBody=$input.body&MessageAttribute.1.Name=EventType&MessageAttribute.1.Value.StringValue="$input.params().header.get('EventType')"&MessageAttribute.1.Value.DataType=String&MessageAttribute.2.Name=SourceSystem&MessageAttribute.2.Value.StringValue="$input.params().header.get('SourceSystem')"&MessageAttribute.2.Value.DataType=String
           # Example (no headers):
           # Action=SendMessage&MessageBody=$input.body
     ```

Always use the correct mapping template for the destination type (Lambda or SQS) and make sure to use the API Gateway integration role ARN you provide as an argument.

API Gateway Integration Role

- The API Gateway integration role ARN should be provided as an argument to the template generator, similar to how the Lambda role ARN is provided for Lambda functions.
- The template should reference the provided API Gateway integration role ARN in the API Gateway integration objects, rather than hardcoding the role definition in the template.

Resource Naming
- Resource names for functions: <function_key>Function (where <function_key> is the exact key from FUNCTIONS_MAP).
